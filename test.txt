1，数据库主外键
https://www.cnblogs.com/liuslayer/p/9082297.html

2，数据的内、左、右、全连接查询
inner join 、left join、right join、union
https://blog.csdn.net/zjt980452483/article/details/82945663

3静态方法与非静态方法的区别
静态类：
在类（class）上加入static修饰， 表示该类无法被实例化，并且该类中，无法实例化变量或函数。
那么如果要在此静态类中添加函数、变量、属性，则必须都是静态的。
静态类的主要特性：
1：仅包含静态成员。
2：无法实例化。 
3：静态类的本质，是一个抽象的密封类，所以不能被继承，也不能被实例化。
4：不能包含实例构造函数。
5：如果一个类下面的所有成员，都需要被共享，那么可以把这个类定义为静态类。
换一句大白话，C# 2.0中引入了static修饰词就是为了控制代码中“静态类内部不允许出现非静态变量或函数”的。 深一层的原因可能只有搞编译器的那些人才知道。
所以，可以在普通类中添加静态方法，但是静态类中的方法、变量都必须是静态的。
 
c#静态方法与非静态方法比较：
一、静态方法：使用static修改的方法就是静态方法，否则就是非静态方法。
二、差异比较：
  第一：C#静态成员：（1）静态成员属于类所有，非静态成员属于类的实例所有。
                                     （2）每创建一个类的实例，都会在内存中为非静态成员新分配一块存储。
           总结：静态成员属于类所有，为各个类的实例所公用，无论类创建了多少实例，类的静态成员在内存中只占同一块区域。
  第二：C#静态方法:     (1)C#静态方法属于类所有，类实例化前即可使用。
                                    （2）非静态方法可以访问类中的任何成员，静态方法只能访问类中的静态成员。                             （3）因为静态方法在类实例化前就可以使用，而类中的非静态变量必须在实例化之后才能分配内存。这样的话C#静态方法调用时无法判断非静态变量使用的内存地址，所以静态方法所以无法使用非静态变量，但静态变量地址对类来说是固定的，所以静态方法可以使用静态变量。
  第三：C#静态方法是一种特殊的成员方法，它不属于类的某一个具体实例，而是属于类本身。所以对于静态方法不需要首先创建一个类的实例，而是采用    类名.静态方法   的格式。
                                     （1）static方法是类中的一个成员方法，属于整个类，即不用创建任何对象也可以直接调用。static方法内部只能出现static变量和其他static方法，而且static方法还不能使用this等关键字（this指的是当前的对象），因为它是属于整个类。
                                      （2）静态方法效率上要比实例化高，静态方法的缺点是不自动进行销毁，而实例化的则可以做销毁。（3）静态方法和静态变量创建后始终使用同一块内存，而使用实例的方式会创建多个内存。           （4）C#中的方法有两种：实例方法、静态方法
 第四：C#静态方法获取类的名称：
                                         （1）静态方法获取类名：
  string className  =System.Reflection.MethodBase.GetCurrentMethod().ReflectedType.FullName;
                                            (2)静态方法获取类名：
 string className =this.GetType().FullName;
 
 4类型转换
 http://c.biancheng.net/view/2839.html
 
 5
onkeypress="event.cancelBubble=true;" 
onkeypress 事件在用户按下并放开任何字母数字键时发生。但是系统按钮（例如：箭头键、功能键）无法得到识别。 
onkeydown 事件在用户按下任何键盘键（包括系统按钮）时发生。 
如果一个事件是可冒泡的,则它的cancelBubble属性的默认值为 false,代表允许该事件向上冒泡. 将cancelBubble属性设置为true以后,可以阻止该事件的进一步冒泡行为.
使用 event.stopPropagation() 方法来代替event.cancelBubble不标准的属性.